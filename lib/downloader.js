// Generated by CoffeeScript 1.7.1
(function() {
  var Downloader, Error, EventEmitter, Log, Path, SpotifyWeb, Track, async, colors, domain, ffmetadata, fs, lodash, mkdirp, program, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  require('coffee-script');

  fs = require('fs');

  async = require('async');

  lodash = require('lodash');

  util = require('util');

  colors = require('colors');

  SpotifyWeb = require('spotify-web');

  mkdirp = require('mkdirp');

  Path = require('path');

  program = require('commander');

  ffmetadata = require("ffmetadata");

  domain = require('domain');

  EventEmitter = require('events').EventEmitter;

  Error = (function(_this) {
    return function(err) {
      console.log(("" + err).red);
      return process.exit(1);
    };
  })(this);

  Log = (function(_this) {
    return function(msg) {
      return console.log((" - " + msg).green);
    };
  })(this);

  Track = (function(_super) {
    __extends(Track, _super);

    function Track(trackId, Spotify, directory, cb, track) {
      this.trackId = trackId;
      this.Spotify = Spotify;
      this.directory = directory;
      this.cb = cb;
      this.track = track != null ? track : {};
      this.writeMetaData = __bind(this.writeMetaData, this);
      this.downloadFile = __bind(this.downloadFile, this);
      this.createDirs = __bind(this.createDirs, this);
      this.getTrack = __bind(this.getTrack, this);
      this.getTrack();
    }

    Track.prototype.getTrack = function() {
      return this.Spotify.get(this.trackId, (function(_this) {
        return function(err, track) {
          if (err) {
            return _this.cb(err);
          }
          _this.track = track;
          return _this.createDirs();
        };
      })(this));
    };

    Track.prototype.createDirs = function() {
      var albumpath, artistpath, dir, filepath, stats;
      dir = Path.resolve("" + this.directory);
      artistpath = dir + '/' + this.track.artist[0].name.replace(/\//g, ' - ') + '/';
      albumpath = artistpath + this.track.album.name.replace(/\//g, ' - ') + ' [' + this.track.album.date.year + ']/';
      filepath = albumpath + this.track.artist[0].name.replace(/\//g, ' - ') + ' - ' + this.track.name.replace(/\//g, ' - ') + '.mp3';
      if (fs.existsSync(filepath)) {
        stats = fs.statSync(filepath);
        if (stats.size !== 0) {
          console.log(("Already Downlaoded: " + this.track.artist[0].name + " " + this.track.name).yellow);
          return this.cb();
        }
      }
      if (!fs.existsSync(albumpath)) {
        mkdirp.sync(albumpath);
      }
      return this.downloadFile(filepath);
    };

    Track.prototype.downloadFile = function(filepath) {
      var d, out;
      Log("Downloading: " + this.track.artist[0].name + " - " + this.track.name);
      out = fs.createWriteStream(filepath);
      d = domain.create();
      d.on('error', (function(_this) {
        return function(err) {
          console.log((" - - " + (err.toString()) + " ...  { Skipping Track }").red);
          return _this.cb();
        };
      })(this));
      return d.run((function(_this) {
        return function() {
          return _this.track.play().pipe(out).on('finish', function() {
            Log(" - DONE: " + _this.track.artist[0].name + " - " + _this.track.name);
            return _this.writeMetaData(filepath);
          });
        };
      })(this));
    };

    Track.prototype.writeMetaData = function(filepath) {
      var id3;
      id3 = {
        artist: this.track.artist[0].name,
        album: this.track.album.name,
        title: this.track.name,
        date: this.track.album.date.year,
        track: this.track.number
      };
      return ffmetadata.write(filepath, id3, this.cb);
    };

    return Track;

  })(EventEmitter);

  Downloader = (function(_super) {
    __extends(Downloader, _super);

    function Downloader(username, password, playlist, directory) {
      this.username = username;
      this.password = password;
      this.playlist = playlist;
      this.directory = directory;
      this.processTrack = __bind(this.processTrack, this);
      this.processTracks = __bind(this.processTracks, this);
      this.getPlaylist = __bind(this.getPlaylist, this);
      this.attemptLogin = __bind(this.attemptLogin, this);
      this.Spotify = null;
      this.Tracks = [];
      console.log('Downloader App Started..'.green);
      async.series([this.attemptLogin, this.getPlaylist, this.processTracks], (function(_this) {
        return function(err, res) {
          if (err) {
            return Error("" + (err.toString()));
          }
          return console.log(' ~ ~ ~ ~ ~ ~ DONEZO ~ ~ ~ ~ ~ ~ ~'.green);
        };
      })(this));
    }

    Downloader.prototype.attemptLogin = function(cb) {
      return SpotifyWeb.login(this.username, this.password, (function(_this) {
        return function(err, SpotifyInstance) {
          if (err) {
            return Error("Error logging in... (" + err + ")");
          }
          _this.Spotify = SpotifyInstance;
          return typeof cb === "function" ? cb() : void 0;
        };
      })(this));
    };

    Downloader.prototype.getPlaylist = function(cb) {
      Log('Getting Playlist Data');
      return this.Spotify.playlist(this.playlist, (function(_this) {
        return function(err, playlistData) {
          if (err) {
            return Error("Playlist data error... " + err);
          }
          Log("Got Playlist: " + playlistData.attributes.name);
          _this.Tracks = lodash.map(playlistData.contents.items, function(item) {
            return item.uri;
          });
          return typeof cb === "function" ? cb() : void 0;
        };
      })(this));
    };

    Downloader.prototype.processTracks = function(cb) {
      Log("Processing " + this.Tracks.length + " Tracks");
      return async.mapSeries(this.Tracks, this.processTrack, cb);
    };

    Downloader.prototype.processTrack = function(track, cb) {
      var TempInstance;
      return TempInstance = new Track(track, this.Spotify, this.directory, cb);
    };

    return Downloader;

  })(EventEmitter);

  module.exports = Downloader;

}).call(this);
